---
title: "Как заставить agentic IDE собирать доступные UI компоненты"
description: "Генерируемые интерфейсы недоступны для пользователей. В статье описано что можно сделать, чтобы вернуть людям хорошие интерфейсы, не теряя скорости разработки."
date: "2025-08-07"
tags:
  [
		"accessibility",
		"vibecoding",
		"windsurf",
		"claude",
		"claude code",
		"react",
		"next.js",
		"nuxt.js",
		"sveltekit",
		"vue.js",
		"a11y",
		"AXE Devtools",
		"Cursor",
		"Cursor Rules",
		"W3C",
		"WCAG",
		"HTML5",
		"Semantics",
		"Radix",
		"ShadCN",
		"диватоз",
		"вайбкодинг",
		"семантика",
		"семантическая верстка"
  ]
lang: "ru"
slug: "keep-a11y-while-vibecoding"
layout: "~/ArticlePage.astro"

# META INFO
main-idea: "Генерируемые интерфейсы теряют свою доступность для пользователей"
why-is-it-important: "Сейчас очень много новых продуктов, где интерфейсы сгенерированы AI агентами, и разработчики снова забывают о том, что их интерфейсами предстоит пользоваться разным людям, совершенно разными способами"
what-reader-could-do-afterwards: "Добавить правила в свою AI IDE, провести небольшой аудит и протестировать свой интерфейс"
---

Вайбкодинг ускорил разработку, в том числе и создание интерфейсов, но вместе с тем принёс старую проблему, которую [сообщество пытается решить](https://developer.mozilla.org/en-US/curriculum/core/semantic-html/) уже более десяти лет — с момента появления HTML5.

> Среди миллиона страниц было обнаружено 50 960 288 различных ошибок доступности - в среднем 51 ошибка на страницу. [Источник](https://webaim.org/projects/million/)

Генерируемые интерфейсы часто страдают «диватозом»: ссылки снова играют роль кнопок, а изображения остаются без альтернативных текстов.

Чтобы исправить эти проблемы, стоит "научить" свою IDE генерировать доступные интерфейсы, при помощи нескольких шагов:

	1. Использовать библиотеки UI компонентов, которые доступны "из коробки";
	2. Добавить правила для агента, чтобы он верстал с учетом требований;
	3. Тестировать сгенерированные интерфейсы.


## Выбор UI библиотеки

К счастью доступность стала трендом, по этому множество компонентных библиотек уже обо всем позаботились, но важно знать друзей в лицо, вот несколько из них:

**React/Next**

1. [Radix](https://www.radix-ui.com/) и [ShadCN](https://ui.shadcn.com/) - Мой персональный топ. Компоненты красивые, собирать и использовать удобно;
2. [Spectrum](https://react-spectrum.adobe.com/react-spectrum/index.html) - К Adobe предъявляются завышенные требования по качеству интерфейсов, по этому эти ребята знают как делать их доступными;
3. [MUI](https://mui.com/) - Production-ready компоненты от Google.

**Vue/Nuxt**

1. [Radix](https://www.radix-vue.com/) и [ShadCN](https://www.shadcn-vue.com/) для Vue - компонентов и возможностей theme'инга меньше, но вайбкодится отлично;
2. [NuxtUI](https://ui.nuxt.com/) - Стилизованный набор компонентов для Nuxt приложений, рекомендую использовать MCP для поиска по компонентам, иногда галлюцинирует;
3. [Reka UI](https://reka-ui.com/) - Тоже самое, только без стилей, как Radix.

**Svelte/SvelteKit**
1. [Radix](https://radix-svelte.com/) и [ShadCN](https://www.shadcn-svelte.com/) - Все тоже самое, по мне самый удобный вариант.
2. [Melt UI](https://www.melt-ui.com/) - В отличии от других библиотек, эта не предоставляет готовые компоненты, но набор функций для построения компонентов из нативных HTML элементов;
3. [Bits UI](https://www.bits-ui.com/) - Целый конструктор доступных компонентов, по сути похоже на Radix.

> Чем проще пользоваться компонентами, тем проще будет и агенту, тем меньше токенов вы потратите на создание опрятных интерфейсов.

Рекомендую использовать **ShadCN** и **TailwindCSS**, это лучшее сочетание для LLM – меньше галлюцинаций, при этом не нужно описывать специальные правила для этого набора.

Для других сочетаний, рекомендую так же создать правила, где подробно описаны примеры использования компонентов и их доступный набор. В идеале использовать MCP, или локальную документацию к набору компонентов который вы решили использовать, и закрепить в правилах, перед внесением изменений в шаблоны, сначала изучить набор компонентов и как их использовать, так вы снизите шансы на галлюцинирование моделей, жертвуя токенами.

## Про правила

В популярных AI IDE есть правила, которые вы можете настраивать глобально и локально для своего проекта:

	1. **Cursor: **`./cursor/rules/{rule_name}.mdc`, можно так же настроить в разделе "Rules & Memory", Cursor Settings;
	2. **Windsurf: **`./.windsurfrules`;
	3. **Claude Code: **`CLAUDE.md`.

Минимально, вы можете добавить всего пару строчек в существующие правила, чтобы IDE учитывала, что не стоит абы как собирать интерфейс:

```text
Accessibility
- Ensure interfaces are keyboard navigable.
- Implement proper ARIA labels and roles for components.
- Ensure color contrast ratios meet WCAG standards for readability.
```

Этого должно хватить чтобы избежать «диватоза», но бывает надо собрать сложный компонент, комбинируя компоненты из UI библиотеки, с нативными тегами, чтобы сделать что-то сложное.

Я создал правила для Cursor, которое должно учитывать любой фреймворк и компонентную библиотеку, там собраны примеры и более точные требования: [Правила для курсора (`.mdc`)](/docs/cursor-accessibility-rules.mdc), но для вашего приложения, рекомендую создать эти правила самостоятельно, учитывая ваш стек, фреймворк, компоненты, архитектурные паттерны и прочее, для этого можно воспользоваться промптом  для Claude, он поможет сгенерировать правила для Cursor, вам нужно только заполнить детали вашего стека – [Промпт для генерации правил](/docs/accessibility-rules-generator-prompt.md).

Для других IDE, используйте те же подходы.

## Тестирование

Невозможно создать интерфейс для людей, не протестировав его самостоятельно. После применения всех правил, используя подходящую библиотеку, просто попробуйте использовать интерфейс который у вас получился, например с клавиатуры, затем используя [скрин-ридер](https://www.doka.guide/a11y/screenreaders/), визуально проверьте что верстка не перегружена ARIA атрибутами, что были использованы готовые компоненты из библиотеки, а там где это невозможно, компоненты созданы учитывая гайдлайны.

## Дополнительные ресурсы и инструменты

- В случае, если «семантика», «доступность», «WCAG» и «W3C» понятия для вас новые, рекомендую посмотреть доклад Вадима Макеева, на тему «людоедских интерфейсов» - [YouTube | Людоедский интерфейс, Вадим Макеев](https://www.youtube.com/watch?v=KAK-WAb9vow), [Eng Ver](https://www.youtube.com/watch?v=1N4t4xpXhmA);
- Готовые правила для курсора, от комьюнити и официальные - [cursor.directory](https://cursor.directory/rules);
- Статья на Веб-стандартах [«аудит доступности»](https://web-standards.ru/articles/a11y-audit-basics/);
- Плагин-тул для браузера для проверки ваших веб страниц - [WAVE (Web Accessibility Evaluation Tool)](https://wave.webaim.org/extension/);
- Обзор основ доступности от W3C (может быть полезно для более точных промптов) - [Accessibility Fundamentals Overview](https://www.w3.org/WAI/fundamentals/)
- Что такое "скринридер" и какие они бывают – [Статья на Доке](https://www.doka.guide/a11y/screenreaders/);
- Набор инструментов, методик и решений для поддержания доступности на всех этапах разработки и работы с продуктами (AXE Devtools, AXE For VS Code, и другие) - [Сайт Deque](https://www.deque.com/).


## Что дальше?

Попробуйте внедрить в свой пайплайн новые правила, начните тестировать интерфейсы.

Можете написать мне, я с радостью помогу настроить ваш IDE, подскажу как протестировать и расскажу как донести важность до стейкхолдеров – [danila@katokdoes.art](mailto:danila@katokdoes.art).
